#开闭原则
一个软件实体 （类 模块 函数）应该对扩展开房，对修改关闭

用抽象构建框架  用实现扩展细节

提高软件的系统的可复用行和可维护性

面向抽象（接口或者抽象类）编程

接口作为契约  必须是稳定

#依赖倒置原则

高层接口不应该依赖底层模块  二者应该依赖其抽象（接口和实现）

不应该依赖于底层细节（实现类）  应该依赖其抽象

针对接口编程  不依赖于实现细节编程


减少类间的耦合性 提高系统的稳定性 提高代码的可读性和可维护性 降低修改程序所造成的风险


#单一职责原则

不要存在多于一个导致类变更的原因

一个类实现两个需求或者功能  任何一个需求和功能的变动都会造成这个类的修改 

一个类/接口/方法只负责一项职责

职责划分  一个职责就是一组接口 一组接口实现一个完整的职责  职责 职责和需求（功能）对应关系 不确定

优点：降低类的复杂度，提高类的可读性 提高系统的可维护性，降低变更引起的风险


#接口隔离原则

用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口

一个类对一个类的依赖应该建立在最少的接口上

建立单一接口，不要建立庞大臃肿的接口

尽量细化接口，接口中的方法尽量的少

注意适度（不多不少，刚刚好）原则，一定要适度

抽象业务模型

针对于接口的隔离  职责的细分   单一职责原则 职责的单一  单一实现的 防止污染  针对于一个业务的不同角度抽象

符合高内聚低耦合的设计思想 从而使得类具有更好的可读性 可扩展行和可维护行


#迪米特原则（最少知道原则）

一个对象应该对其他对象保持最少的了解  最少知道原则

尽量降低类与类之间的耦合  访问控制符的使用

适度使用

一个方法可以增加到A类中  也可以增加到B类中  选一个进步增加类间关系  又不对类产生负面影响的类

只和朋友交流 不和陌生人说话

朋友：出现在成员变量，方法的输入 输出参数中的类称为朋友类

出现在方法体内部的类不属于朋友类

我附庸的附庸不是我的附庸


#@里式替换原则

如果对每一个类型为T1的对象o1,都有类型T2的对象o2使得以T1定义的所有程序P在所有对象o1都替换成o2时，
程序P的行为没有发生变化，那么类型T2是类型T1的子类型

扩展：一个软件实体如果使用一个父类的话，拿一定适用于其子类，所有引用父类的地方必须能透明的使用其子类的对象
子类能替换父类，而程序逻辑不变

反对子类重写父类方法

子类可以扩展父类的功能，单不能改变父类原有的功能

子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法

子类可以增加自己特有的方法

子类的方法重载父类的方法是 方法的前置条件（即方法的输入和入参）要比父类方法的输入参数更宽松

子类的方法实现父类的方法是（重写/重载 或实现抽象方法），方法的后置条件（方法的输出/返回值）要比父类更严格或者相等


约束继承泛滥，开闭原则的一种体现

加强程序的健壮性，同时变更是也可以做到非常好的兼容性 提高程序的可维护行，可扩展行 降低需求变更是引入的风险


#@合成（组合）/聚合复用原则

优先使用对象组合/聚合，而不是继承关系达到软件复用的目的

聚合 has-A和组合contains-A

可以使系统更加灵活 降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少

黑箱复用和白箱复用

组合管理的对象多（黑箱复用）   继承扩展性  破坏包装 （白箱复用）

选择

继承 is-A

继承 要遵循里式替换原则

依赖之间用接口和抽象类表示  接口要单一职责 粒度合适 依赖的方式有三种  属性（set方法,构造函数）,参数































