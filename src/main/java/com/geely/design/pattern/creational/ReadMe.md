#开闭原则
一个软件实体 （类 模块 函数）应该对扩展开放，对修改关闭

用抽象构建框架  用实现扩展细节

提高软件的系统的可复用行和可维护性

面向抽象（接口或者抽象类）编程

接口作为契约  必须是稳定

#依赖倒置原则

高层接口不应该依赖底层模块  二者应该依赖其抽象（接口和实现）

不应该依赖于底层细节（实现类）  应该依赖其抽象

针对接口编程  不依赖于实现细节编程


减少类间的耦合性 提高系统的稳定性 提高代码的可读性和可维护性 降低修改程序所造成的风险


#单一职责原则

不要存在多于一个导致类变更的原因

一个类实现两个需求或者功能  任何一个需求和功能的变动都会造成这个类的修改 

一个类/接口/方法只负责一项职责

职责划分  一个职责就是一组接口 一组接口实现一个完整的职责  职责 职责和需求（功能）对应关系 不确定

优点：降低类的复杂度，提高类的可读性 提高系统的可维护性，降低变更引起的风险


#接口隔离原则

用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口

一个类对一个类的依赖应该建立在最少的接口上

建立单一接口，不要建立庞大臃肿的接口

尽量细化接口，接口中的方法尽量的少

注意适度（不多不少，刚刚好）原则，一定要适度

抽象业务模型

针对于接口的隔离  职责的细分   单一职责原则 职责的单一  单一实现的 防止污染  针对于一个业务的不同角度抽象

符合高内聚低耦合的设计思想 从而使得类具有更好的可读性 可扩展行和可维护行


#迪米特原则（最少知道原则）

一个对象应该对其他对象保持最少的了解  最少知道原则

尽量降低类与类之间的耦合  访问控制符的使用

适度使用

一个方法可以增加到A类中  也可以增加到B类中  选一个进步增加类间关系  又不对类产生负面影响的类

只和朋友交流 不和陌生人说话

朋友：出现在成员变量，方法的输入 输出参数中的类称为朋友类

出现在方法体内部的类不属于朋友类

我附庸的附庸不是我的附庸


#里式替换原则

如果对每一个类型为T1的对象o1,都有类型T2的对象o2使得以T1定义的所有程序P在所有对象o1都替换成o2时，
程序P的行为没有发生变化，那么类型T2是类型T1的子类型

扩展：一个软件实体如果使用一个父类的话，拿一定适用于其子类，所有引用父类的地方必须能透明的使用其子类的对象
子类能替换父类，而程序逻辑不变

反对子类重写父类方法

子类可以扩展父类的功能，单不能改变父类原有的功能

子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法

子类可以增加自己特有的方法

子类的方法重载父类的方法是 方法的前置条件（即方法的输入和入参）要比父类方法的输入参数更宽松

子类的方法实现父类的方法是（重写/重载 或实现抽象方法），方法的后置条件（方法的输出/返回值）要比父类更严格或者相等


约束继承泛滥，开闭原则的一种体现

加强程序的健壮性，同时变更是也可以做到非常好的兼容性 提高程序的可维护行，可扩展行 降低需求变更是引入的风险


#合成（组合）/聚合复用原则

优先使用对象组合/聚合，而不是继承关系达到软件复用的目的

聚合 has-A和组合contains-A

可以使系统更加灵活 降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少

黑箱复用和白箱复用

组合管理的对象多（黑箱复用）   继承扩展性，破坏包装 （白箱复用）

选择

继承 is-A

继承 要遵循里式替换原则

依赖之间用接口和抽象类表示  接口要单一职责 粒度合适 依赖的方式有三种  属性（set方法,构造函数）,参数


#简单工厂模式

有一个工厂对象决定创建出哪一种产品实例

类型：创建型，但不属于GOF23中设计模式

根据入参选择不同的返回实例

使用场景 ：
工厂类负责创建的对象比较少  
客户端（应用层）只知道传入工厂类的参数 对于如何创建对象（逻辑）不关心


只需要传入一个正确的参数 就可以获取你所需要的对象无需知道其创建细节

责任分割

工厂类的职责相对过重 增加新的产品 需要修改工厂类的判断逻辑，违背开闭原则


增加了类的个数

无法形成继承的结构


Calendar Calendar getInstance

DriverManager Connection getConnection com.mysql.cj.jdbc.Driver



#工厂方法

定义一个创建对象的接口 但让实现这个接口的类来决定实例化哪一个类，工厂方法让类的实例化

类型：创建型

工厂方法使用的场景:

创建对象需要大量重复的代码

客户端（应用层）不依赖于产品类实例如何被创建，实现等细节

一个类通过子类来指定创建那个对象

对象实现和里式替换原则

用户只需要关心所需产品对应的工厂，无须关心创建细节

加入新产品符合开闭原则  提高可扩展性

针对产品等级

缺点：类的个数容易过多 增加复杂度

增加系统的抽象性和理解难度

java.util.Collection.iterator  工厂方法 使用 java.util.Iterator 作为工厂的方法 具体的实现例如ArrayList
 的 Iterator   Itr implements Iterator<E>


java.net.URLStreamHandlerFactory  和  java.net.URLStreamHandler


org.slf4j.LoggerFactory    ILoggerFactory   ch.qos.logback.classic.LoggerContext

#抽象工厂
抽象工厂模式提供一个创建一系列相关或者相互依赖对象的接口

无须指定具体的类

类型：创建型

客户端（应用层）不依赖于产品类实例如何被创建，实现等细节

强调一系列相关产品对象（属于同一产品族）一起使用创建对象需要大量重复代码

提供一个产品类的库  所有的产品已同样的接口出现 从而是客户端不依赖于具体的实现

优点：具体产品在应用层代码隔离 无须关心创建细节

将一个系列的产品族统一到一起创建

针对产品族

规定了所有可能被创建的产品集合 产品族中扩展新的产品困难 需要修改抽象工厂方法的接口

增加系统的抽象性和理解难度

产品的等级接口和产品族

java.sql.Connection

SqlSessionFactory

java.sql.Statement


#建造者


需要复杂的步骤，步骤和步骤之间的关系不确定

java.lang.StringBuilder

com.google.common.collect.ImmutableSet

com.google.common.cache.CacheBuilder

org.springframework.beans.factory.support.BeanDefinitionBuilder

org.apache.ibatis.session.SqlSessionFactoryBuilder

#单例模式

保证一个类仅有一个实例，并提供一个全局访问点

类型：创建型


任何情况下都绝对只有一个实例

计数器   配置   线程池  数据库连接池  http连接池


只有一个实例  减少内存开销

可以避免对资源的多重占用

设置全局访问点 严格控制访问

没有接口  扩展困难

私有构造器  线程安全 延迟加载   序列化  反序列化安全  反射（攻击）


* 单例-Double Check 


单例模式和工厂模式

单例模式和享元模式

java.lang.ThreadLocal

org.springframework.beans.factory.config.AbstractFactoryBean

org.apache.ibatis.executor.ErrorContext

java.awt.Desktop

java.lang.Runtime

#@原型-定义与类型


对象创建的成本很高  选择克隆  java的克隆接口重写Object的克隆方法，深克隆（对象流实现） 浅克隆  
